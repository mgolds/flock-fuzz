{"ast":null,"code":"// Class for representing a single boid\nclass SimpleBoid {\n  constructor(p, x, y) {\n    // Store p5 instance\n    this.p = p;\n\n    // Position\n    this.x = x;\n    this.y = y;\n\n    // Generate random velocity\n    const angle = p.random(p.TWO_PI);\n    const speed = p.random(2, 4);\n    this.vx = p.cos(angle) * speed;\n    this.vy = p.sin(angle) * speed;\n\n    // Acceleration\n    this.ax = 0;\n    this.ay = 0;\n\n    // Properties\n    this.maxSpeed = 5;\n    this.maxForce = 0.2;\n    this.size = p.random(3, 6);\n  }\n\n  // Apply flocking behavior\n  flock(boids, params) {\n    // Reset acceleration\n    this.ax = 0;\n    this.ay = 0;\n\n    // Calculate forces\n    const separation = this.separate(boids);\n    const alignment = this.align(boids);\n    const cohesion = this.cohere(boids);\n\n    // Apply weights from params\n    separation.x *= params.separation || 1.5;\n    separation.y *= params.separation || 1.5;\n    alignment.x *= params.alignment || 1.0;\n    alignment.y *= params.alignment || 1.0;\n    cohesion.x *= params.cohesion || 1.0;\n    cohesion.y *= params.cohesion || 1.0;\n\n    // Add all forces to acceleration\n    this.ax += separation.x + alignment.x + cohesion.x;\n    this.ay += separation.y + alignment.y + cohesion.y;\n  }\n\n  // Update position and velocity\n  update() {\n    // Update velocity with acceleration\n    this.vx += this.ax;\n    this.vy += this.ay;\n\n    // Limit speed\n    const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);\n    if (speed > this.maxSpeed) {\n      this.vx = this.vx / speed * this.maxSpeed;\n      this.vy = this.vy / speed * this.maxSpeed;\n    }\n\n    // Update position\n    this.x += this.vx;\n    this.y += this.vy;\n  }\n\n  // Wrap around edges\n  edges() {\n    const p = this.p;\n    if (this.x > p.width) this.x = 0;\n    if (this.x < 0) this.x = p.width;\n    if (this.y > p.height) this.y = 0;\n    if (this.y < 0) this.y = p.height;\n  }\n\n  // Draw the boid\n  show() {\n    const p = this.p;\n\n    // Calculate heading angle\n    const angle = Math.atan2(this.vy, this.vx) + p.HALF_PI;\n    p.push();\n    p.translate(this.x, this.y);\n    p.rotate(angle);\n\n    // Draw triangle\n    p.fill(255);\n    p.noStroke();\n    p.beginShape();\n    p.vertex(0, -this.size * 2);\n    p.vertex(-this.size, this.size * 2);\n    p.vertex(this.size, this.size * 2);\n    p.endShape(p.CLOSE);\n    p.pop();\n  }\n\n  // Calculate separation force\n  separate(boids) {\n    const perception = 40;\n    let steerX = 0;\n    let steerY = 0;\n    let count = 0;\n    for (const other of boids) {\n      const dx = this.x - other.x;\n      const dy = this.y - other.y;\n      const d = Math.sqrt(dx * dx + dy * dy);\n      if (other !== this && d < perception) {\n        // Weight by distance\n        steerX += dx / d;\n        steerY += dy / d;\n        count++;\n      }\n    }\n    if (count > 0) {\n      steerX /= count;\n      steerY /= count;\n\n      // Set to max speed\n      const mag = Math.sqrt(steerX * steerX + steerY * steerY);\n      steerX = steerX / mag * this.maxSpeed;\n      steerY = steerY / mag * this.maxSpeed;\n\n      // Subtract current velocity\n      steerX -= this.vx;\n      steerY -= this.vy;\n\n      // Limit force\n      const forceMag = Math.sqrt(steerX * steerX + steerY * steerY);\n      if (forceMag > this.maxForce) {\n        steerX = steerX / forceMag * this.maxForce;\n        steerY = steerY / forceMag * this.maxForce;\n      }\n    }\n    return {\n      x: steerX,\n      y: steerY\n    };\n  }\n\n  // Calculate alignment force\n  align(boids) {\n    const perception = 50;\n    let steerX = 0;\n    let steerY = 0;\n    let count = 0;\n    for (const other of boids) {\n      const dx = this.x - other.x;\n      const dy = this.y - other.y;\n      const d = Math.sqrt(dx * dx + dy * dy);\n      if (other !== this && d < perception) {\n        steerX += other.vx;\n        steerY += other.vy;\n        count++;\n      }\n    }\n    if (count > 0) {\n      steerX /= count;\n      steerY /= count;\n\n      // Set to max speed\n      const mag = Math.sqrt(steerX * steerX + steerY * steerY);\n      steerX = steerX / mag * this.maxSpeed;\n      steerY = steerY / mag * this.maxSpeed;\n\n      // Subtract current velocity\n      steerX -= this.vx;\n      steerY -= this.vy;\n\n      // Limit force\n      const forceMag = Math.sqrt(steerX * steerX + steerY * steerY);\n      if (forceMag > this.maxForce) {\n        steerX = steerX / forceMag * this.maxForce;\n        steerY = steerY / forceMag * this.maxForce;\n      }\n    }\n    return {\n      x: steerX,\n      y: steerY\n    };\n  }\n\n  // Calculate cohesion force\n  cohere(boids) {\n    const perception = 80;\n    let targetX = 0;\n    let targetY = 0;\n    let count = 0;\n    for (const other of boids) {\n      const dx = this.x - other.x;\n      const dy = this.y - other.y;\n      const d = Math.sqrt(dx * dx + dy * dy);\n      if (other !== this && d < perception) {\n        targetX += other.x;\n        targetY += other.y;\n        count++;\n      }\n    }\n    if (count > 0) {\n      targetX /= count;\n      targetY /= count;\n\n      // Direction to target\n      let steerX = targetX - this.x;\n      let steerY = targetY - this.y;\n\n      // Set to max speed\n      const mag = Math.sqrt(steerX * steerX + steerY * steerY);\n      if (mag > 0) {\n        steerX = steerX / mag * this.maxSpeed;\n        steerY = steerY / mag * this.maxSpeed;\n      }\n\n      // Subtract current velocity\n      steerX -= this.vx;\n      steerY -= this.vy;\n\n      // Limit force\n      const forceMag = Math.sqrt(steerX * steerX + steerY * steerY);\n      if (forceMag > this.maxForce) {\n        steerX = steerX / forceMag * this.maxForce;\n        steerY = steerY / forceMag * this.maxForce;\n      }\n      return {\n        x: steerX,\n        y: steerY\n      };\n    } else {\n      return {\n        x: 0,\n        y: 0\n      };\n    }\n  }\n}\nexport default SimpleBoid;","map":{"version":3,"names":["SimpleBoid","constructor","p","x","y","angle","random","TWO_PI","speed","vx","cos","vy","sin","ax","ay","maxSpeed","maxForce","size","flock","boids","params","separation","separate","alignment","align","cohesion","cohere","update","Math","sqrt","edges","width","height","show","atan2","HALF_PI","push","translate","rotate","fill","noStroke","beginShape","vertex","endShape","CLOSE","pop","perception","steerX","steerY","count","other","dx","dy","d","mag","forceMag","targetX","targetY"],"sources":["C:/Users/mttgo/OneDrive/Desktop/Cursor Projects/webapps/flocking-app/src/sketches/simpleBoid.js"],"sourcesContent":["// Class for representing a single boid\r\nclass SimpleBoid {\r\n  constructor(p, x, y) {\r\n    // Store p5 instance\r\n    this.p = p;\r\n    \r\n    // Position\r\n    this.x = x;\r\n    this.y = y;\r\n    \r\n    // Generate random velocity\r\n    const angle = p.random(p.TWO_PI);\r\n    const speed = p.random(2, 4);\r\n    this.vx = p.cos(angle) * speed;\r\n    this.vy = p.sin(angle) * speed;\r\n    \r\n    // Acceleration\r\n    this.ax = 0;\r\n    this.ay = 0;\r\n    \r\n    // Properties\r\n    this.maxSpeed = 5;\r\n    this.maxForce = 0.2;\r\n    this.size = p.random(3, 6);\r\n  }\r\n  \r\n  // Apply flocking behavior\r\n  flock(boids, params) {\r\n    // Reset acceleration\r\n    this.ax = 0;\r\n    this.ay = 0;\r\n    \r\n    // Calculate forces\r\n    const separation = this.separate(boids);\r\n    const alignment = this.align(boids);\r\n    const cohesion = this.cohere(boids);\r\n    \r\n    // Apply weights from params\r\n    separation.x *= params.separation || 1.5;\r\n    separation.y *= params.separation || 1.5;\r\n    \r\n    alignment.x *= params.alignment || 1.0;\r\n    alignment.y *= params.alignment || 1.0;\r\n    \r\n    cohesion.x *= params.cohesion || 1.0;\r\n    cohesion.y *= params.cohesion || 1.0;\r\n    \r\n    // Add all forces to acceleration\r\n    this.ax += separation.x + alignment.x + cohesion.x;\r\n    this.ay += separation.y + alignment.y + cohesion.y;\r\n  }\r\n  \r\n  // Update position and velocity\r\n  update() {\r\n    // Update velocity with acceleration\r\n    this.vx += this.ax;\r\n    this.vy += this.ay;\r\n    \r\n    // Limit speed\r\n    const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);\r\n    if (speed > this.maxSpeed) {\r\n      this.vx = (this.vx / speed) * this.maxSpeed;\r\n      this.vy = (this.vy / speed) * this.maxSpeed;\r\n    }\r\n    \r\n    // Update position\r\n    this.x += this.vx;\r\n    this.y += this.vy;\r\n  }\r\n  \r\n  // Wrap around edges\r\n  edges() {\r\n    const p = this.p;\r\n    if (this.x > p.width) this.x = 0;\r\n    if (this.x < 0) this.x = p.width;\r\n    if (this.y > p.height) this.y = 0;\r\n    if (this.y < 0) this.y = p.height;\r\n  }\r\n  \r\n  // Draw the boid\r\n  show() {\r\n    const p = this.p;\r\n    \r\n    // Calculate heading angle\r\n    const angle = Math.atan2(this.vy, this.vx) + p.HALF_PI;\r\n    \r\n    p.push();\r\n    p.translate(this.x, this.y);\r\n    p.rotate(angle);\r\n    \r\n    // Draw triangle\r\n    p.fill(255);\r\n    p.noStroke();\r\n    p.beginShape();\r\n    p.vertex(0, -this.size * 2);\r\n    p.vertex(-this.size, this.size * 2);\r\n    p.vertex(this.size, this.size * 2);\r\n    p.endShape(p.CLOSE);\r\n    \r\n    p.pop();\r\n  }\r\n  \r\n  // Calculate separation force\r\n  separate(boids) {\r\n    const perception = 40;\r\n    let steerX = 0;\r\n    let steerY = 0;\r\n    let count = 0;\r\n    \r\n    for (const other of boids) {\r\n      const dx = this.x - other.x;\r\n      const dy = this.y - other.y;\r\n      const d = Math.sqrt(dx * dx + dy * dy);\r\n      \r\n      if (other !== this && d < perception) {\r\n        // Weight by distance\r\n        steerX += dx / d;\r\n        steerY += dy / d;\r\n        count++;\r\n      }\r\n    }\r\n    \r\n    if (count > 0) {\r\n      steerX /= count;\r\n      steerY /= count;\r\n      \r\n      // Set to max speed\r\n      const mag = Math.sqrt(steerX * steerX + steerY * steerY);\r\n      steerX = steerX / mag * this.maxSpeed;\r\n      steerY = steerY / mag * this.maxSpeed;\r\n      \r\n      // Subtract current velocity\r\n      steerX -= this.vx;\r\n      steerY -= this.vy;\r\n      \r\n      // Limit force\r\n      const forceMag = Math.sqrt(steerX * steerX + steerY * steerY);\r\n      if (forceMag > this.maxForce) {\r\n        steerX = (steerX / forceMag) * this.maxForce;\r\n        steerY = (steerY / forceMag) * this.maxForce;\r\n      }\r\n    }\r\n    \r\n    return { x: steerX, y: steerY };\r\n  }\r\n  \r\n  // Calculate alignment force\r\n  align(boids) {\r\n    const perception = 50;\r\n    let steerX = 0;\r\n    let steerY = 0;\r\n    let count = 0;\r\n    \r\n    for (const other of boids) {\r\n      const dx = this.x - other.x;\r\n      const dy = this.y - other.y;\r\n      const d = Math.sqrt(dx * dx + dy * dy);\r\n      \r\n      if (other !== this && d < perception) {\r\n        steerX += other.vx;\r\n        steerY += other.vy;\r\n        count++;\r\n      }\r\n    }\r\n    \r\n    if (count > 0) {\r\n      steerX /= count;\r\n      steerY /= count;\r\n      \r\n      // Set to max speed\r\n      const mag = Math.sqrt(steerX * steerX + steerY * steerY);\r\n      steerX = steerX / mag * this.maxSpeed;\r\n      steerY = steerY / mag * this.maxSpeed;\r\n      \r\n      // Subtract current velocity\r\n      steerX -= this.vx;\r\n      steerY -= this.vy;\r\n      \r\n      // Limit force\r\n      const forceMag = Math.sqrt(steerX * steerX + steerY * steerY);\r\n      if (forceMag > this.maxForce) {\r\n        steerX = (steerX / forceMag) * this.maxForce;\r\n        steerY = (steerY / forceMag) * this.maxForce;\r\n      }\r\n    }\r\n    \r\n    return { x: steerX, y: steerY };\r\n  }\r\n  \r\n  // Calculate cohesion force\r\n  cohere(boids) {\r\n    const perception = 80;\r\n    let targetX = 0;\r\n    let targetY = 0;\r\n    let count = 0;\r\n    \r\n    for (const other of boids) {\r\n      const dx = this.x - other.x;\r\n      const dy = this.y - other.y;\r\n      const d = Math.sqrt(dx * dx + dy * dy);\r\n      \r\n      if (other !== this && d < perception) {\r\n        targetX += other.x;\r\n        targetY += other.y;\r\n        count++;\r\n      }\r\n    }\r\n    \r\n    if (count > 0) {\r\n      targetX /= count;\r\n      targetY /= count;\r\n      \r\n      // Direction to target\r\n      let steerX = targetX - this.x;\r\n      let steerY = targetY - this.y;\r\n      \r\n      // Set to max speed\r\n      const mag = Math.sqrt(steerX * steerX + steerY * steerY);\r\n      if (mag > 0) {\r\n        steerX = steerX / mag * this.maxSpeed;\r\n        steerY = steerY / mag * this.maxSpeed;\r\n      }\r\n      \r\n      // Subtract current velocity\r\n      steerX -= this.vx;\r\n      steerY -= this.vy;\r\n      \r\n      // Limit force\r\n      const forceMag = Math.sqrt(steerX * steerX + steerY * steerY);\r\n      if (forceMag > this.maxForce) {\r\n        steerX = (steerX / forceMag) * this.maxForce;\r\n        steerY = (steerY / forceMag) * this.maxForce;\r\n      }\r\n      \r\n      return { x: steerX, y: steerY };\r\n    } else {\r\n      return { x: 0, y: 0 };\r\n    }\r\n  }\r\n}\r\n\r\nexport default SimpleBoid; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}