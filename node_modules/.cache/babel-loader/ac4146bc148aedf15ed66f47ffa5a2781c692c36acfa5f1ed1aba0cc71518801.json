{"ast":null,"code":"// Class for representing a single boid\nclass SimpleBoid {\n  constructor(p, x, y, settings, id) {\n    // Store p5 instance\n    this.p = p;\n    this.id = id || 0;\n\n    // Position\n    this.x = x;\n    this.y = y;\n\n    // Generate random velocity\n    const angle = p.random(p.TWO_PI);\n    const speed = p.random(2, 4);\n    this.vx = p.cos(angle) * speed;\n    this.vy = p.sin(angle) * speed;\n\n    // Acceleration\n    this.ax = 0;\n    this.ay = 0;\n\n    // Properties\n    this.maxSpeed = 5;\n    this.maxForce = 0.2;\n    this.size = p.random(3, 6);\n\n    // Trail history\n    this.trail = []; // Array to store position history\n\n    // Apply settings\n    this.updateSettings(settings);\n\n    // Random color for this boid (used in random color mode)\n    this.color = this.generateRandomColor();\n  }\n  updateSettings(settings) {\n    if (!settings) return;\n\n    // Store settings\n    this.settings = settings;\n\n    // Trail settings\n    this.maxTrailLength = settings.trailLength || 50;\n    this.trailOpacity = this.p.random(40, 80); // For variety\n\n    // Size multiplier\n    this.sizeMultiplier = settings.agentSize || 1;\n  }\n  generateRandomColor() {\n    return {\n      r: Math.floor(Math.random() * 256),\n      g: Math.floor(Math.random() * 256),\n      b: Math.floor(Math.random() * 256)\n    };\n  }\n\n  // Apply flocking behavior\n  flock(boids, params) {\n    // Reset acceleration\n    this.ax = 0;\n    this.ay = 0;\n\n    // Calculate forces\n    const separation = this.separate(boids);\n    const alignment = this.align(boids);\n    const cohesion = this.cohere(boids);\n\n    // Apply weights from params\n    separation.x *= params.separation || 1.5;\n    separation.y *= params.separation || 1.5;\n    alignment.x *= params.alignment || 1.0;\n    alignment.y *= params.alignment || 1.0;\n    cohesion.x *= params.cohesion || 1.0;\n    cohesion.y *= params.cohesion || 1.0;\n\n    // Add all forces to acceleration\n    this.ax += separation.x + alignment.x + cohesion.x;\n    this.ay += separation.y + alignment.y + cohesion.y;\n  }\n\n  // Update position and velocity\n  update() {\n    // Update velocity with acceleration\n    this.vx += this.ax;\n    this.vy += this.ay;\n\n    // Limit speed\n    const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);\n    if (speed > this.maxSpeed) {\n      this.vx = this.vx / speed * this.maxSpeed;\n      this.vy = this.vy / speed * this.maxSpeed;\n    }\n\n    // Add current position to trail before updating\n    this.addToTrail(this.x, this.y);\n\n    // Update position\n    this.x += this.vx;\n    this.y += this.vy;\n  }\n\n  // Add current position to the trail\n  addToTrail(x, y) {\n    // Only add if we want trails\n    if (this.maxTrailLength <= 0) return;\n    this.trail.push({\n      x,\n      y\n    });\n    // Keep trail at maximum length\n    if (this.trail.length > this.maxTrailLength) {\n      this.trail.shift(); // Remove the oldest position\n    }\n  }\n\n  // Wrap around edges\n  edges() {\n    const p = this.p;\n    const settings = this.settings || {};\n\n    // When wrapping around edges, clear the trail to avoid visual jumps\n    // (unless we want to keep trails)\n    if (this.x > p.width) {\n      this.x = 0;\n      if (!settings.keepTrails) this.clearTrail();\n    }\n    if (this.x < 0) {\n      this.x = p.width;\n      if (!settings.keepTrails) this.clearTrail();\n    }\n    if (this.y > p.height) {\n      this.y = 0;\n      if (!settings.keepTrails) this.clearTrail();\n    }\n    if (this.y < 0) {\n      this.y = p.height;\n      if (!settings.keepTrails) this.clearTrail();\n    }\n  }\n\n  // Clear the trail when wrapping around screen edges\n  clearTrail() {\n    this.trail = [];\n  }\n\n  // Draw the boid\n  show() {\n    const p = this.p;\n    const settings = this.settings || {};\n\n    // Draw the trail first\n    this.drawTrail();\n\n    // Calculate heading angle\n    const angle = Math.atan2(this.vy, this.vx) + p.HALF_PI;\n\n    // Get agent color\n    let agentColor;\n    if (settings.colors && settings.colors.agent) {\n      // Convert hex to RGB\n      agentColor = this.hexToRgb(settings.colors.agent);\n    } else {\n      agentColor = {\n        r: 255,\n        g: 255,\n        b: 255\n      };\n    }\n    p.push();\n    p.translate(this.x, this.y);\n    p.rotate(angle);\n\n    // Set the fill color\n    p.fill(agentColor.r, agentColor.g, agentColor.b);\n    p.noStroke();\n\n    // Size based on settings\n    const size = this.size * this.sizeMultiplier;\n\n    // Draw the appropriate shape based on settings\n    const shape = settings.agentShape || 'triangle';\n    switch (shape) {\n      case 'circle':\n        p.ellipse(0, 0, size * 2);\n        break;\n      case 'square':\n        p.rectMode(p.CENTER);\n        p.rect(0, 0, size * 2, size * 2);\n        break;\n      case 'custom':\n        // Example custom shape - could be customized more\n        p.beginShape();\n        p.vertex(0, -size * 2);\n        p.vertex(-size, size);\n        p.vertex(0, 0);\n        p.vertex(size, size);\n        p.endShape(p.CLOSE);\n        break;\n      case 'triangle':\n      default:\n        // Triangle is the default shape\n        p.beginShape();\n        p.vertex(0, -size * 2);\n        p.vertex(-size, size * 2);\n        p.vertex(size, size * 2);\n        p.endShape(p.CLOSE);\n    }\n    p.pop();\n  }\n\n  // Draw the trail for this boid\n  drawTrail() {\n    const p = this.p;\n    const settings = this.settings || {};\n    if (this.trail.length < 2) return;\n\n    // Get color based on settings\n    let trailColor;\n    const colorRandomnessValue = settings.colorRandomness || 0;\n\n    // First determine base color by colorMode\n    let baseColor;\n    switch (settings.colorMode) {\n      case 'random':\n        // Use this boid's random color\n        baseColor = this.color;\n        break;\n      case 'gradient':\n        // Use gradient colors\n        if (settings.colors && settings.colors.start && settings.colors.end) {\n          // For gradient, we'll use the boid's ID to determine color\n          const startColor = this.hexToRgb(settings.colors.start);\n          const endColor = this.hexToRgb(settings.colors.end);\n\n          // Simple interpolation based on ID\n          const t = this.id % 10 / 10;\n          baseColor = {\n            r: startColor.r + (endColor.r - startColor.r) * t,\n            g: startColor.g + (endColor.g - startColor.g) * t,\n            b: startColor.b + (endColor.b - startColor.b) * t\n          };\n        } else {\n          baseColor = {\n            r: 255,\n            g: 255,\n            b: 255\n          };\n        }\n        break;\n      case 'single':\n      default:\n        // Use single color if specified, otherwise white\n        if (settings.colors && settings.colors.main) {\n          baseColor = this.hexToRgb(settings.colors.main);\n        } else {\n          baseColor = {\n            r: 255,\n            g: 255,\n            b: 255\n          };\n        }\n    }\n\n    // Apply colorRandomness if needed\n    if (colorRandomnessValue > 0) {\n      // Generate random color component\n      const randomColor = this.generateRandomColor();\n\n      // Mix base color with random color according to randomness percentage\n      const mixFactor = colorRandomnessValue / 100;\n      trailColor = {\n        r: Math.round(baseColor.r * (1 - mixFactor) + randomColor.r * mixFactor),\n        g: Math.round(baseColor.g * (1 - mixFactor) + randomColor.g * mixFactor),\n        b: Math.round(baseColor.b * (1 - mixFactor) + randomColor.b * mixFactor)\n      };\n    } else {\n      trailColor = baseColor;\n    }\n\n    // Set stroke attributes based on settings\n    p.strokeWeight(settings.trailThickness || 0.5);\n\n    // Set opacity\n    const opacity = this.trailOpacity;\n    p.stroke(trailColor.r, trailColor.g, trailColor.b, opacity);\n    p.noFill();\n\n    // Draw based on trail type\n    switch (settings.trailType) {\n      case 'dashed':\n        this.drawDashedLine();\n        break;\n      case 'dotted':\n        this.drawDottedLine();\n        break;\n      case 'points':\n        this.drawPointsLine();\n        break;\n      case 'line':\n      default:\n        this.drawSolidLine();\n    }\n  }\n\n  // Draw a solid line for the trail\n  drawSolidLine() {\n    const p = this.p;\n    p.beginShape();\n    for (const point of this.trail) {\n      p.vertex(point.x, point.y);\n    }\n    p.endShape();\n  }\n\n  // Draw a dashed line for the trail\n  drawDashedLine() {\n    const p = this.p;\n    for (let i = 1; i < this.trail.length; i++) {\n      if (i % 2 === 0) continue; // Skip every other segment for dash effect\n\n      const prev = this.trail[i - 1];\n      const curr = this.trail[i];\n      p.line(prev.x, prev.y, curr.x, curr.y);\n    }\n  }\n\n  // Draw a dotted line for the trail\n  drawDottedLine() {\n    const p = this.p;\n    for (let i = 0; i < this.trail.length; i++) {\n      if (i % 2 === 0) {\n        // Draw dots at every other point\n        const point = this.trail[i];\n        p.ellipse(point.x, point.y, 2);\n      }\n    }\n  }\n\n  // Draw points for the trail\n  drawPointsLine() {\n    const p = this.p;\n    for (const point of this.trail) {\n      p.point(point.x, point.y);\n    }\n  }\n\n  // Helper function to convert hex color to RGB\n  hexToRgb(hex) {\n    // Remove # if present\n    hex = hex.replace('#', '');\n\n    // Parse hex values\n    const r = parseInt(hex.substring(0, 2), 16);\n    const g = parseInt(hex.substring(2, 4), 16);\n    const b = parseInt(hex.substring(4, 6), 16);\n    return {\n      r,\n      g,\n      b\n    };\n  }\n\n  // Calculate separation force\n  separate(boids) {\n    const perception = 40;\n    let steerX = 0;\n    let steerY = 0;\n    let count = 0;\n    for (const other of boids) {\n      const dx = this.x - other.x;\n      const dy = this.y - other.y;\n      const d = Math.sqrt(dx * dx + dy * dy);\n      if (other !== this && d < perception) {\n        // Weight by distance\n        steerX += dx / d;\n        steerY += dy / d;\n        count++;\n      }\n    }\n    if (count > 0) {\n      steerX /= count;\n      steerY /= count;\n\n      // Set to max speed\n      const mag = Math.sqrt(steerX * steerX + steerY * steerY);\n      steerX = steerX / mag * this.maxSpeed;\n      steerY = steerY / mag * this.maxSpeed;\n\n      // Subtract current velocity\n      steerX -= this.vx;\n      steerY -= this.vy;\n\n      // Limit force\n      const forceMag = Math.sqrt(steerX * steerX + steerY * steerY);\n      if (forceMag > this.maxForce) {\n        steerX = steerX / forceMag * this.maxForce;\n        steerY = steerY / forceMag * this.maxForce;\n      }\n    }\n    return {\n      x: steerX,\n      y: steerY\n    };\n  }\n\n  // Calculate alignment force\n  align(boids) {\n    const perception = 50;\n    let steerX = 0;\n    let steerY = 0;\n    let count = 0;\n    for (const other of boids) {\n      const dx = this.x - other.x;\n      const dy = this.y - other.y;\n      const d = Math.sqrt(dx * dx + dy * dy);\n      if (other !== this && d < perception) {\n        steerX += other.vx;\n        steerY += other.vy;\n        count++;\n      }\n    }\n    if (count > 0) {\n      steerX /= count;\n      steerY /= count;\n\n      // Set to max speed\n      const mag = Math.sqrt(steerX * steerX + steerY * steerY);\n      steerX = steerX / mag * this.maxSpeed;\n      steerY = steerY / mag * this.maxSpeed;\n\n      // Subtract current velocity\n      steerX -= this.vx;\n      steerY -= this.vy;\n\n      // Limit force\n      const forceMag = Math.sqrt(steerX * steerX + steerY * steerY);\n      if (forceMag > this.maxForce) {\n        steerX = steerX / forceMag * this.maxForce;\n        steerY = steerY / forceMag * this.maxForce;\n      }\n    }\n    return {\n      x: steerX,\n      y: steerY\n    };\n  }\n\n  // Calculate cohesion force\n  cohere(boids) {\n    const perception = 80;\n    let targetX = 0;\n    let targetY = 0;\n    let count = 0;\n    for (const other of boids) {\n      const dx = this.x - other.x;\n      const dy = this.y - other.y;\n      const d = Math.sqrt(dx * dx + dy * dy);\n      if (other !== this && d < perception) {\n        targetX += other.x;\n        targetY += other.y;\n        count++;\n      }\n    }\n    if (count > 0) {\n      targetX /= count;\n      targetY /= count;\n\n      // Direction to target\n      let steerX = targetX - this.x;\n      let steerY = targetY - this.y;\n\n      // Set to max speed\n      const mag = Math.sqrt(steerX * steerX + steerY * steerY);\n      if (mag > 0) {\n        steerX = steerX / mag * this.maxSpeed;\n        steerY = steerY / mag * this.maxSpeed;\n      }\n\n      // Subtract current velocity\n      steerX -= this.vx;\n      steerY -= this.vy;\n\n      // Limit force\n      const forceMag = Math.sqrt(steerX * steerX + steerY * steerY);\n      if (forceMag > this.maxForce) {\n        steerX = steerX / forceMag * this.maxForce;\n        steerY = steerY / forceMag * this.maxForce;\n      }\n      return {\n        x: steerX,\n        y: steerY\n      };\n    } else {\n      return {\n        x: 0,\n        y: 0\n      };\n    }\n  }\n}\nexport default SimpleBoid;","map":{"version":3,"names":["SimpleBoid","constructor","p","x","y","settings","id","angle","random","TWO_PI","speed","vx","cos","vy","sin","ax","ay","maxSpeed","maxForce","size","trail","updateSettings","color","generateRandomColor","maxTrailLength","trailLength","trailOpacity","sizeMultiplier","agentSize","r","Math","floor","g","b","flock","boids","params","separation","separate","alignment","align","cohesion","cohere","update","sqrt","addToTrail","push","length","shift","edges","width","keepTrails","clearTrail","height","show","drawTrail","atan2","HALF_PI","agentColor","colors","agent","hexToRgb","translate","rotate","fill","noStroke","shape","agentShape","ellipse","rectMode","CENTER","rect","beginShape","vertex","endShape","CLOSE","pop","trailColor","colorRandomnessValue","colorRandomness","baseColor","colorMode","start","end","startColor","endColor","t","main","randomColor","mixFactor","round","strokeWeight","trailThickness","opacity","stroke","noFill","trailType","drawDashedLine","drawDottedLine","drawPointsLine","drawSolidLine","point","i","prev","curr","line","hex","replace","parseInt","substring","perception","steerX","steerY","count","other","dx","dy","d","mag","forceMag","targetX","targetY"],"sources":["C:/Users/mttgo/OneDrive/Desktop/Cursor Projects/webapps/flocking-app/src/sketches/simpleBoid.js"],"sourcesContent":["// Class for representing a single boid\r\nclass SimpleBoid {\r\n  constructor(p, x, y, settings, id) {\r\n    // Store p5 instance\r\n    this.p = p;\r\n    this.id = id || 0;\r\n    \r\n    // Position\r\n    this.x = x;\r\n    this.y = y;\r\n    \r\n    // Generate random velocity\r\n    const angle = p.random(p.TWO_PI);\r\n    const speed = p.random(2, 4);\r\n    this.vx = p.cos(angle) * speed;\r\n    this.vy = p.sin(angle) * speed;\r\n    \r\n    // Acceleration\r\n    this.ax = 0;\r\n    this.ay = 0;\r\n    \r\n    // Properties\r\n    this.maxSpeed = 5;\r\n    this.maxForce = 0.2;\r\n    this.size = p.random(3, 6);\r\n    \r\n    // Trail history\r\n    this.trail = []; // Array to store position history\r\n    \r\n    // Apply settings\r\n    this.updateSettings(settings);\r\n    \r\n    // Random color for this boid (used in random color mode)\r\n    this.color = this.generateRandomColor();\r\n  }\r\n  \r\n  updateSettings(settings) {\r\n    if (!settings) return;\r\n    \r\n    // Store settings\r\n    this.settings = settings;\r\n    \r\n    // Trail settings\r\n    this.maxTrailLength = settings.trailLength || 50;\r\n    this.trailOpacity = this.p.random(40, 80); // For variety\r\n    \r\n    // Size multiplier\r\n    this.sizeMultiplier = settings.agentSize || 1;\r\n  }\r\n  \r\n  generateRandomColor() {\r\n    return {\r\n      r: Math.floor(Math.random() * 256),\r\n      g: Math.floor(Math.random() * 256),\r\n      b: Math.floor(Math.random() * 256)\r\n    };\r\n  }\r\n  \r\n  // Apply flocking behavior\r\n  flock(boids, params) {\r\n    // Reset acceleration\r\n    this.ax = 0;\r\n    this.ay = 0;\r\n    \r\n    // Calculate forces\r\n    const separation = this.separate(boids);\r\n    const alignment = this.align(boids);\r\n    const cohesion = this.cohere(boids);\r\n    \r\n    // Apply weights from params\r\n    separation.x *= params.separation || 1.5;\r\n    separation.y *= params.separation || 1.5;\r\n    \r\n    alignment.x *= params.alignment || 1.0;\r\n    alignment.y *= params.alignment || 1.0;\r\n    \r\n    cohesion.x *= params.cohesion || 1.0;\r\n    cohesion.y *= params.cohesion || 1.0;\r\n    \r\n    // Add all forces to acceleration\r\n    this.ax += separation.x + alignment.x + cohesion.x;\r\n    this.ay += separation.y + alignment.y + cohesion.y;\r\n  }\r\n  \r\n  // Update position and velocity\r\n  update() {\r\n    // Update velocity with acceleration\r\n    this.vx += this.ax;\r\n    this.vy += this.ay;\r\n    \r\n    // Limit speed\r\n    const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);\r\n    if (speed > this.maxSpeed) {\r\n      this.vx = (this.vx / speed) * this.maxSpeed;\r\n      this.vy = (this.vy / speed) * this.maxSpeed;\r\n    }\r\n    \r\n    // Add current position to trail before updating\r\n    this.addToTrail(this.x, this.y);\r\n    \r\n    // Update position\r\n    this.x += this.vx;\r\n    this.y += this.vy;\r\n  }\r\n  \r\n  // Add current position to the trail\r\n  addToTrail(x, y) {\r\n    // Only add if we want trails\r\n    if (this.maxTrailLength <= 0) return;\r\n    \r\n    this.trail.push({x, y});\r\n    // Keep trail at maximum length\r\n    if (this.trail.length > this.maxTrailLength) {\r\n      this.trail.shift(); // Remove the oldest position\r\n    }\r\n  }\r\n  \r\n  // Wrap around edges\r\n  edges() {\r\n    const p = this.p;\r\n    const settings = this.settings || {};\r\n    \r\n    // When wrapping around edges, clear the trail to avoid visual jumps\r\n    // (unless we want to keep trails)\r\n    if (this.x > p.width) {\r\n      this.x = 0;\r\n      if (!settings.keepTrails) this.clearTrail();\r\n    }\r\n    if (this.x < 0) {\r\n      this.x = p.width;\r\n      if (!settings.keepTrails) this.clearTrail();\r\n    }\r\n    if (this.y > p.height) {\r\n      this.y = 0;\r\n      if (!settings.keepTrails) this.clearTrail();\r\n    }\r\n    if (this.y < 0) {\r\n      this.y = p.height;\r\n      if (!settings.keepTrails) this.clearTrail();\r\n    }\r\n  }\r\n  \r\n  // Clear the trail when wrapping around screen edges\r\n  clearTrail() {\r\n    this.trail = [];\r\n  }\r\n  \r\n  // Draw the boid\r\n  show() {\r\n    const p = this.p;\r\n    const settings = this.settings || {};\r\n    \r\n    // Draw the trail first\r\n    this.drawTrail();\r\n    \r\n    // Calculate heading angle\r\n    const angle = Math.atan2(this.vy, this.vx) + p.HALF_PI;\r\n    \r\n    // Get agent color\r\n    let agentColor;\r\n    if (settings.colors && settings.colors.agent) {\r\n      // Convert hex to RGB\r\n      agentColor = this.hexToRgb(settings.colors.agent);\r\n    } else {\r\n      agentColor = { r: 255, g: 255, b: 255 };\r\n    }\r\n    \r\n    p.push();\r\n    p.translate(this.x, this.y);\r\n    p.rotate(angle);\r\n    \r\n    // Set the fill color\r\n    p.fill(agentColor.r, agentColor.g, agentColor.b);\r\n    p.noStroke();\r\n    \r\n    // Size based on settings\r\n    const size = this.size * this.sizeMultiplier;\r\n    \r\n    // Draw the appropriate shape based on settings\r\n    const shape = settings.agentShape || 'triangle';\r\n    switch (shape) {\r\n      case 'circle':\r\n        p.ellipse(0, 0, size * 2);\r\n        break;\r\n      case 'square':\r\n        p.rectMode(p.CENTER);\r\n        p.rect(0, 0, size * 2, size * 2);\r\n        break;\r\n      case 'custom':\r\n        // Example custom shape - could be customized more\r\n        p.beginShape();\r\n        p.vertex(0, -size * 2);\r\n        p.vertex(-size, size);\r\n        p.vertex(0, 0);\r\n        p.vertex(size, size);\r\n        p.endShape(p.CLOSE);\r\n        break;\r\n      case 'triangle':\r\n      default:\r\n        // Triangle is the default shape\r\n        p.beginShape();\r\n        p.vertex(0, -size * 2);\r\n        p.vertex(-size, size * 2);\r\n        p.vertex(size, size * 2);\r\n        p.endShape(p.CLOSE);\r\n    }\r\n    \r\n    p.pop();\r\n  }\r\n  \r\n  // Draw the trail for this boid\r\n  drawTrail() {\r\n    const p = this.p;\r\n    const settings = this.settings || {};\r\n    \r\n    if (this.trail.length < 2) return;\r\n    \r\n    // Get color based on settings\r\n    let trailColor;\r\n    const colorRandomnessValue = settings.colorRandomness || 0;\r\n    \r\n    // First determine base color by colorMode\r\n    let baseColor;\r\n    switch (settings.colorMode) {\r\n      case 'random':\r\n        // Use this boid's random color\r\n        baseColor = this.color;\r\n        break;\r\n      case 'gradient':\r\n        // Use gradient colors\r\n        if (settings.colors && settings.colors.start && settings.colors.end) {\r\n          // For gradient, we'll use the boid's ID to determine color\r\n          const startColor = this.hexToRgb(settings.colors.start);\r\n          const endColor = this.hexToRgb(settings.colors.end);\r\n          \r\n          // Simple interpolation based on ID\r\n          const t = (this.id % 10) / 10;\r\n          baseColor = {\r\n            r: startColor.r + (endColor.r - startColor.r) * t,\r\n            g: startColor.g + (endColor.g - startColor.g) * t,\r\n            b: startColor.b + (endColor.b - startColor.b) * t\r\n          };\r\n        } else {\r\n          baseColor = { r: 255, g: 255, b: 255 };\r\n        }\r\n        break;\r\n      case 'single':\r\n      default:\r\n        // Use single color if specified, otherwise white\r\n        if (settings.colors && settings.colors.main) {\r\n          baseColor = this.hexToRgb(settings.colors.main);\r\n        } else {\r\n          baseColor = { r: 255, g: 255, b: 255 };\r\n        }\r\n    }\r\n    \r\n    // Apply colorRandomness if needed\r\n    if (colorRandomnessValue > 0) {\r\n      // Generate random color component\r\n      const randomColor = this.generateRandomColor();\r\n      \r\n      // Mix base color with random color according to randomness percentage\r\n      const mixFactor = colorRandomnessValue / 100;\r\n      trailColor = {\r\n        r: Math.round(baseColor.r * (1 - mixFactor) + randomColor.r * mixFactor),\r\n        g: Math.round(baseColor.g * (1 - mixFactor) + randomColor.g * mixFactor),\r\n        b: Math.round(baseColor.b * (1 - mixFactor) + randomColor.b * mixFactor)\r\n      };\r\n    } else {\r\n      trailColor = baseColor;\r\n    }\r\n    \r\n    // Set stroke attributes based on settings\r\n    p.strokeWeight(settings.trailThickness || 0.5);\r\n    \r\n    // Set opacity\r\n    const opacity = this.trailOpacity;\r\n    p.stroke(trailColor.r, trailColor.g, trailColor.b, opacity);\r\n    p.noFill();\r\n    \r\n    // Draw based on trail type\r\n    switch (settings.trailType) {\r\n      case 'dashed':\r\n        this.drawDashedLine();\r\n        break;\r\n      case 'dotted':\r\n        this.drawDottedLine();\r\n        break;\r\n      case 'points':\r\n        this.drawPointsLine();\r\n        break;\r\n      case 'line':\r\n      default:\r\n        this.drawSolidLine();\r\n    }\r\n  }\r\n  \r\n  // Draw a solid line for the trail\r\n  drawSolidLine() {\r\n    const p = this.p;\r\n    \r\n    p.beginShape();\r\n    for (const point of this.trail) {\r\n      p.vertex(point.x, point.y);\r\n    }\r\n    p.endShape();\r\n  }\r\n  \r\n  // Draw a dashed line for the trail\r\n  drawDashedLine() {\r\n    const p = this.p;\r\n    \r\n    for (let i = 1; i < this.trail.length; i++) {\r\n      if (i % 2 === 0) continue; // Skip every other segment for dash effect\r\n      \r\n      const prev = this.trail[i-1];\r\n      const curr = this.trail[i];\r\n      p.line(prev.x, prev.y, curr.x, curr.y);\r\n    }\r\n  }\r\n  \r\n  // Draw a dotted line for the trail\r\n  drawDottedLine() {\r\n    const p = this.p;\r\n    \r\n    for (let i = 0; i < this.trail.length; i++) {\r\n      if (i % 2 === 0) { // Draw dots at every other point\r\n        const point = this.trail[i];\r\n        p.ellipse(point.x, point.y, 2);\r\n      }\r\n    }\r\n  }\r\n  \r\n  // Draw points for the trail\r\n  drawPointsLine() {\r\n    const p = this.p;\r\n    \r\n    for (const point of this.trail) {\r\n      p.point(point.x, point.y);\r\n    }\r\n  }\r\n  \r\n  // Helper function to convert hex color to RGB\r\n  hexToRgb(hex) {\r\n    // Remove # if present\r\n    hex = hex.replace('#', '');\r\n    \r\n    // Parse hex values\r\n    const r = parseInt(hex.substring(0, 2), 16);\r\n    const g = parseInt(hex.substring(2, 4), 16);\r\n    const b = parseInt(hex.substring(4, 6), 16);\r\n    \r\n    return { r, g, b };\r\n  }\r\n  \r\n  // Calculate separation force\r\n  separate(boids) {\r\n    const perception = 40;\r\n    let steerX = 0;\r\n    let steerY = 0;\r\n    let count = 0;\r\n    \r\n    for (const other of boids) {\r\n      const dx = this.x - other.x;\r\n      const dy = this.y - other.y;\r\n      const d = Math.sqrt(dx * dx + dy * dy);\r\n      \r\n      if (other !== this && d < perception) {\r\n        // Weight by distance\r\n        steerX += dx / d;\r\n        steerY += dy / d;\r\n        count++;\r\n      }\r\n    }\r\n    \r\n    if (count > 0) {\r\n      steerX /= count;\r\n      steerY /= count;\r\n      \r\n      // Set to max speed\r\n      const mag = Math.sqrt(steerX * steerX + steerY * steerY);\r\n      steerX = steerX / mag * this.maxSpeed;\r\n      steerY = steerY / mag * this.maxSpeed;\r\n      \r\n      // Subtract current velocity\r\n      steerX -= this.vx;\r\n      steerY -= this.vy;\r\n      \r\n      // Limit force\r\n      const forceMag = Math.sqrt(steerX * steerX + steerY * steerY);\r\n      if (forceMag > this.maxForce) {\r\n        steerX = (steerX / forceMag) * this.maxForce;\r\n        steerY = (steerY / forceMag) * this.maxForce;\r\n      }\r\n    }\r\n    \r\n    return { x: steerX, y: steerY };\r\n  }\r\n  \r\n  // Calculate alignment force\r\n  align(boids) {\r\n    const perception = 50;\r\n    let steerX = 0;\r\n    let steerY = 0;\r\n    let count = 0;\r\n    \r\n    for (const other of boids) {\r\n      const dx = this.x - other.x;\r\n      const dy = this.y - other.y;\r\n      const d = Math.sqrt(dx * dx + dy * dy);\r\n      \r\n      if (other !== this && d < perception) {\r\n        steerX += other.vx;\r\n        steerY += other.vy;\r\n        count++;\r\n      }\r\n    }\r\n    \r\n    if (count > 0) {\r\n      steerX /= count;\r\n      steerY /= count;\r\n      \r\n      // Set to max speed\r\n      const mag = Math.sqrt(steerX * steerX + steerY * steerY);\r\n      steerX = steerX / mag * this.maxSpeed;\r\n      steerY = steerY / mag * this.maxSpeed;\r\n      \r\n      // Subtract current velocity\r\n      steerX -= this.vx;\r\n      steerY -= this.vy;\r\n      \r\n      // Limit force\r\n      const forceMag = Math.sqrt(steerX * steerX + steerY * steerY);\r\n      if (forceMag > this.maxForce) {\r\n        steerX = (steerX / forceMag) * this.maxForce;\r\n        steerY = (steerY / forceMag) * this.maxForce;\r\n      }\r\n    }\r\n    \r\n    return { x: steerX, y: steerY };\r\n  }\r\n  \r\n  // Calculate cohesion force\r\n  cohere(boids) {\r\n    const perception = 80;\r\n    let targetX = 0;\r\n    let targetY = 0;\r\n    let count = 0;\r\n    \r\n    for (const other of boids) {\r\n      const dx = this.x - other.x;\r\n      const dy = this.y - other.y;\r\n      const d = Math.sqrt(dx * dx + dy * dy);\r\n      \r\n      if (other !== this && d < perception) {\r\n        targetX += other.x;\r\n        targetY += other.y;\r\n        count++;\r\n      }\r\n    }\r\n    \r\n    if (count > 0) {\r\n      targetX /= count;\r\n      targetY /= count;\r\n      \r\n      // Direction to target\r\n      let steerX = targetX - this.x;\r\n      let steerY = targetY - this.y;\r\n      \r\n      // Set to max speed\r\n      const mag = Math.sqrt(steerX * steerX + steerY * steerY);\r\n      if (mag > 0) {\r\n        steerX = steerX / mag * this.maxSpeed;\r\n        steerY = steerY / mag * this.maxSpeed;\r\n      }\r\n      \r\n      // Subtract current velocity\r\n      steerX -= this.vx;\r\n      steerY -= this.vy;\r\n      \r\n      // Limit force\r\n      const forceMag = Math.sqrt(steerX * steerX + steerY * steerY);\r\n      if (forceMag > this.maxForce) {\r\n        steerX = (steerX / forceMag) * this.maxForce;\r\n        steerY = (steerY / forceMag) * this.maxForce;\r\n      }\r\n      \r\n      return { x: steerX, y: steerY };\r\n    } else {\r\n      return { x: 0, y: 0 };\r\n    }\r\n  }\r\n}\r\n\r\nexport default SimpleBoid; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}